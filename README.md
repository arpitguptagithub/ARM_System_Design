# Compiler for a Custom Language and TAC-to-VM Conversion

## Overview

This repository contains two essential components:

1. **`prob1.y`**: A YACC file that defines a custom programming language's grammar, syntax, and semantic rules. It generates a Three-Address Code (TAC) as the intermediate representation.
2. **`TAC-VM3.cpp`**: A C++ program that translates TAC into Virtual Machine (VM) instructions.

The compiler and converter form a pipeline for transforming high-level code into VM-executable instructions. Below is a detailed breakdown of each file and its usage.

---

## File Details

### `prob1.y`

#### Purpose
This YACC file implements the compiler front end for a custom programming language. It parses the language syntax, validates semantics, and generates TAC.

#### Key Features
The file supports the following features:

1. **Arithmetic Operations**:
   - Operators: `+`, `-`, `*`, `/`
   - Handles precedence and associativity.

2. **Logical and Relational Operations**:
   - Relational operators: `>`, `<`, `>=`, `<=`, `==`, `!=`
   - Logical operators: `&&`, `||`, `!`

3. **Variable Declarations and Assignments**:
   - Supports scalar variables and array declarations.
   - Example:
     ```c
     int a;
     int arr[10];
     a = 5;
     arr[2] = 15;
     ```

4. **Control Flow Statements**:
   - **Conditionals**:
     - `if` and `if-else` constructs with support for nested statements.
   - **Loops**:
     - `while` and `for` loops for iterative tasks.

5. **Function Definitions and Calls**:
   - Allows user-defined functions with parameters and return types.
   - Example:
     ```c
     int add(int a, int b) {
         return a + b;
     }
     ```
   - Generates appropriate TAC for function calls and returns.

6. **Input and Output**:
   - **Input**: Read values using `SCAN` statements.
     ```c
     SCAN(a);
     ```
   - **Output**: Print values using `PRINT` statements.
     ```c
     PRINT(a);
     ```

7. **Array Indexing and Operations**:
   - Arrays are supported with bounds-checking logic.
   - Allows operations on array elements:
     ```c
     arr[i] = arr[j] + 1;
     ```

8. **Error Handling**:
   - Reports syntax errors with detailed messages for debugging.

#### Output
- **TAC Generation**: For every language construct, TAC is generated.
  - Example for `a = b + c;`:
    ```tac
    t1 = b + c
    a = t1
    ```

---

### `TAC-VM3.cpp`

#### Purpose
This C++ program translates the TAC generated by `prob1.y` into a sequence of VM instructions suitable for execution on a virtual machine.

#### Key Features
- **Operator Translation**:
  - Maps arithmetic, logical, and relational operations to VM instructions.
  - Example: `+` becomes `addi`.

- **Type and Memory Management**:
  - Handles variables, constants, and temporary registers efficiently.
  - Supports array indexing and function arguments.

- **Control Flow Handling**:
  - Converts labels, conditionals, loops, and function calls into VM instructions.

#### Output
- **VM Instructions**: Generates VM-compatible code, such as:
  ```vm
  push local 0
  push constant 1
  Addi
  pop local 1
  ```

---

## How to Use

### Prerequisites
- A C compiler (e.g., GCC) for compiling the parser and TAC-to-VM converter.
- YACC and Lex for generating the parser from `prob1.y`.

### Steps
1. **Compile `prob1.y`**:
   ```bash
   yacc -d prob1.y
   cc -o parser y.tab.c -ll
   ```
2. **Parse Source Code**:
   ```bash
   ./parser < source_code.txt > tac.txt
   ```
3. **Convert TAC to VM Instructions**:
   - Compile the converter:
     ```bash
     g++ TAC-VM3.cpp -o tac_to_vm
     ```
   - Run the converter:
     ```bash
     ./tac_to_vm > vm_instructions.txt
     ```

---

## Example Workflow

1. Write the source code (`for.ppc`) in the custom language:
   ```c
   
   int main(){
    int i = 0;
    FOR( i=0; i<10; i=i+1){
        int a = 5;
        int b = 10;
        int z = a + b;
        IF(i == 4){
           continue; 
        }
        IF(i == 5){
            break;
        }
    }
   RETURN 0;   
   }

   ```

2. Generate TAC:
   ```bash
   ./parser < for.ppc > for.tac
   ```
   **Example TAC Output**:
   ```tac
   00101510450
   main: INT
   @t0 = 0 INT
   - INT i
   i = @t0 INT
   @t1 = 0 INT
   i = @t1 INT
   #L1:
   @t2 = 10 INT
   @t3 = i < @t2 INT
   @t4 = ~ @t3 INT
   if @t4 GOTO #L3 else GOTO #L2
   #L4:
   @t4 = 1 INT
   @t3 = i + @t4 INT
   i = @t3 INT
   GOTO #L1
   #L2:
   @t3 = 5 INT
   - INT a
   a = @t3 INT
   @t5 = 10 INT
   - INT b
   b = @t5 INT
   @t6 = a + b INT
   - INT z
   z = @t6 INT
   @t6 = 4 INT
   @t7 = i == @t6 INT
   @t8 = ~ @t7 INT
   if @t8 GOTO #L8
   GOTO #L4
   GOTO #L7
   #L8:
   #L7:
   @t8 = 5 INT
   @t7 = i == @t8 INT
   @t9 = ~ @t7 INT
   if @t9 GOTO #L10
   GOTO #L3
   GOTO #L9
   #L10:
   #L9:
   GOTO #L4
   #L3:
   @t9 = 0 INT
   return @t9 
   end: 

   ```

3. Convert TAC to VM Instructions:
   ```bash
   ./tac_to_vm > for.vm
   ```
   **Example VM Output**:
   ```vm
   
   function main 4
   push constant 0
   pop temp 0
   push temp 0
   pop local 0
   push constant 0
   pop temp 1
   push temp 1
   pop local 0
   label #L1   
   push constant 10
   pop temp 2
   push local 0
   push temp 2
   ls
   pop temp 3
   push temp 3
   not
   pop temp 4
   push temp 4
   if-goto #L3
   goto #L2
   label #L4
   push constant 1
   pop temp 4
   push local 0
   push temp 4
   addi
   pop temp 3
   push temp 3
   pop local 0
   goto #L1
   label #L2
   push constant 5
   pop temp 3
   push temp 3
   pop local 1
   push constant 10
   pop temp 5
   push temp 5
   pop local 2
   push local 1
   push local 2
   addi
   pop temp 6
   push temp 6
   pop local 3
   push constant 4
   pop temp 6
   push local 0
   push temp 6
   eq
   pop temp 7
   push temp 7
   not
   pop temp 8
   push temp 8
   if-goto #L8
   goto #L4
   goto #L7
   label #L8
   label #L7
   push constant 5
   pop temp 8
   push local 0
   push temp 8
   eq
   pop temp 7
   push temp 7
   not
   pop temp 9
   push temp 9
   if-goto #L10
   goto #L3
   goto #L9
   label #L10
   label #L9
   goto #L4
   label #L3
   push constant 0
   pop temp 9
   push temp 9
   return

   ```

